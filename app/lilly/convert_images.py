#!/usr/bin/env python3
"""
Convert JPG images to RGB565 C arrays for the Lilly ornament display.

Usage: python convert_images.py

Reads all .jpg/.jpeg/.png files from src/img/
Outputs: src/generated/images.c and src/generated/images.h
"""

import os
import sys
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow not installed. Run: pip install Pillow")
    sys.exit(1)

# Configuration
DISPLAY_WIDTH = 240
DISPLAY_HEIGHT = 240
IMG_DIR = Path(__file__).parent / "src" / "img"
OUT_DIR = Path(__file__).parent / "src" / "generated"


def rgb888_to_rgb565(r, g, b):
    """Convert 8-bit RGB to 16-bit RGB565."""
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)


def process_image(img_path):
    """Load image, resize/crop to 240x240, convert to RGB565."""
    img = Image.open(img_path).convert("RGB")

    # Center crop to square
    width, height = img.size
    min_dim = min(width, height)
    left = (width - min_dim) // 2
    top = (height - min_dim) // 2
    img = img.crop((left, top, left + min_dim, top + min_dim))

    # Resize to display size
    img = img.resize((DISPLAY_WIDTH, DISPLAY_HEIGHT), Image.LANCZOS)

    # Convert to RGB565
    pixels = []
    for y in range(DISPLAY_HEIGHT):
        for x in range(DISPLAY_WIDTH):
            r, g, b = img.getpixel((x, y))
            rgb565 = rgb888_to_rgb565(r, g, b)
            pixels.append(rgb565)

    return pixels


def sanitize_name(filename):
    """Convert filename to valid C identifier."""
    name = Path(filename).stem
    name = ''.join(c if c.isalnum() else '_' for c in name)
    if name[0].isdigit():
        name = '_' + name
    return name


def generate_c_files(images):
    """Generate images.c and images.h files."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    # Generate header file
    header_content = f"""/* Auto-generated by convert_images.py - DO NOT EDIT */
#ifndef IMAGES_H
#define IMAGES_H

#include <stdint.h>
#include <stddef.h>

typedef struct {{
    const uint16_t *data;
    size_t width;
    size_t height;
    size_t size;
    const char *name;
}} image_t;

#define IMAGE_COUNT {len(images)}
#define IMAGE_WIDTH {DISPLAY_WIDTH}
#define IMAGE_HEIGHT {DISPLAY_HEIGHT}

extern const image_t images[IMAGE_COUNT];

#endif /* IMAGES_H */
"""

    with open(OUT_DIR / "images.h", "w") as f:
        f.write(header_content)

    # Generate C file
    c_content = """/* Auto-generated by convert_images.py - DO NOT EDIT */
#include "images.h"

"""

    # Write each image array
    for name, pixels in images:
        c_content += f"static const uint16_t {name}_data[{len(pixels)}] = {{\n"

        # Write pixels in rows of 12
        for i in range(0, len(pixels), 12):
            row = pixels[i:i+12]
            c_content += "    " + ", ".join(f"0x{p:04X}" for p in row) + ",\n"

        c_content = c_content.rstrip(",\n") + "\n};\n\n"

    # Write image struct array
    c_content += "const image_t images[IMAGE_COUNT] = {\n"
    for name, pixels in images:
        c_content += f'    {{ {name}_data, {DISPLAY_WIDTH}, {DISPLAY_HEIGHT}, {len(pixels)}, "{name}" }},\n'
    c_content = c_content.rstrip(",\n") + "\n};\n"

    with open(OUT_DIR / "images.c", "w") as f:
        f.write(c_content)

    print(f"Generated {OUT_DIR / 'images.h'}")
    print(f"Generated {OUT_DIR / 'images.c'}")


def needs_regeneration():
    """Check if images need to be regenerated."""
    c_file = OUT_DIR / "images.c"
    h_file = OUT_DIR / "images.h"

    if not c_file.exists() or not h_file.exists():
        return True

    # Get newest image modification time
    img_extensions = {'.jpg', '.jpeg', '.png'}
    newest_img = 0
    for f in IMG_DIR.iterdir():
        if f.suffix.lower() in img_extensions:
            newest_img = max(newest_img, f.stat().st_mtime)

    # Get generated file modification time
    generated_time = min(c_file.stat().st_mtime, h_file.stat().st_mtime)

    return newest_img > generated_time


def main():
    if not IMG_DIR.exists():
        print(f"Image directory not found: {IMG_DIR}")
        sys.exit(1)

    # Check if regeneration needed (unless forced)
    force = "--force" in sys.argv
    if not force and not needs_regeneration():
        print("Images up to date, skipping generation")
        return 0

    # Find all images
    img_extensions = {'.jpg', '.jpeg', '.png'}
    img_files = sorted([f for f in IMG_DIR.iterdir()
                        if f.suffix.lower() in img_extensions])

    if not img_files:
        print(f"No images found in {IMG_DIR}")
        sys.exit(1)

    print(f"Converting {len(img_files)} images to RGB565...")

    images = []
    for img_path in img_files:
        name = sanitize_name(img_path.name)
        print(f"  Processing {img_path.name} -> {name}")
        pixels = process_image(img_path)
        images.append((name, pixels))

    generate_c_files(images)

    total_bytes = sum(len(pixels) * 2 for _, pixels in images)
    print(f"Total image data: {total_bytes:,} bytes ({total_bytes/1024:.1f} KB)")

    return 0


if __name__ == "__main__":
    sys.exit(main())

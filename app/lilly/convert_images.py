#!/usr/bin/env python3
"""
Convert JPG images to RGB888 C arrays for the Lilly ornament display.

RGB888 format enables fast crossfade blending (simple 8-bit math).
Conversion to RGB565 happens at display time.

Usage: python convert_images.py

Reads all .jpg/.jpeg/.png files from src/img/
Outputs: src/generated/images.c and src/generated/images.h
"""

import os
import sys
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow not installed. Run: pip install Pillow")
    sys.exit(1)

# Configuration
DISPLAY_WIDTH = 240
DISPLAY_HEIGHT = 240
IMG_DIR = Path(__file__).parent / "src" / "img"
OUT_DIR = Path(__file__).parent / "src" / "generated"


def process_image(img_path):
    """Load image, resize/crop to 240x240, rotate 180° for tree hanging, return RGB888 bytes."""
    img = Image.open(img_path).convert("RGB")

    # Center crop to square
    width, height = img.size
    min_dim = min(width, height)
    left = (width - min_dim) // 2
    top = (height - min_dim) // 2
    img = img.crop((left, top, left + min_dim, top + min_dim))

    # Resize to display size
    img = img.resize((DISPLAY_WIDTH, DISPLAY_HEIGHT), Image.LANCZOS)

    # Rotate 180° so images are right-side-up when ornament hangs from tree
    img = img.rotate(180)

    # Extract RGB888 bytes [R, G, B, R, G, B, ...]
    pixels = []
    for y in range(DISPLAY_HEIGHT):
        for x in range(DISPLAY_WIDTH):
            r, g, b = img.getpixel((x, y))
            pixels.extend([r, g, b])

    return pixels


def sanitize_name(filename):
    """Convert filename to valid C identifier."""
    name = Path(filename).stem
    name = ''.join(c if c.isalnum() else '_' for c in name)
    if name[0].isdigit():
        name = '_' + name
    return name


def generate_c_files(images):
    """Generate images.c and images.h files."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    pixel_count = DISPLAY_WIDTH * DISPLAY_HEIGHT

    # Generate header file
    header_content = f"""/* Auto-generated by convert_images.py - DO NOT EDIT */
#ifndef IMAGES_H
#define IMAGES_H

#include <stdint.h>
#include <stddef.h>

/*
 * Images stored as RGB888 (3 bytes per pixel) for fast crossfade blending.
 * Layout: [R0, G0, B0, R1, G1, B1, ...]
 * Conversion to RGB565 happens at display time.
 */
typedef struct {{
    const uint8_t *data;   /* RGB888 pixel data */
    const char *name;
}} image_t;

#define IMAGE_COUNT {len(images)}
#define IMAGE_WIDTH {DISPLAY_WIDTH}
#define IMAGE_HEIGHT {DISPLAY_HEIGHT}
#define IMAGE_PIXELS {pixel_count}
#define IMAGE_STRIDE 3  /* bytes per pixel (RGB888) */

extern const image_t images[IMAGE_COUNT];

#endif /* IMAGES_H */
"""

    with open(OUT_DIR / "images.h", "w") as f:
        f.write(header_content)

    # Generate C file
    c_content = """/* Auto-generated by convert_images.py - DO NOT EDIT */
#include "images.h"

"""

    # Write each image array
    for name, pixels in images:
        c_content += f"static const uint8_t {name}_data[{len(pixels)}] = {{\n"

        # Write bytes in rows of 24 (8 pixels worth)
        for i in range(0, len(pixels), 24):
            row = pixels[i:i+24]
            c_content += "    " + ", ".join(f"0x{b:02X}" for b in row) + ",\n"

        c_content = c_content.rstrip(",\n") + "\n};\n\n"

    # Write image struct array
    c_content += "const image_t images[IMAGE_COUNT] = {\n"
    for name, pixels in images:
        c_content += f'    {{ {name}_data, "{name}" }},\n'
    c_content = c_content.rstrip(",\n") + "\n};\n"

    with open(OUT_DIR / "images.c", "w") as f:
        f.write(c_content)

    print(f"Generated {OUT_DIR / 'images.h'}")
    print(f"Generated {OUT_DIR / 'images.c'}")


def needs_regeneration():
    """Check if images need to be regenerated."""
    c_file = OUT_DIR / "images.c"
    h_file = OUT_DIR / "images.h"

    if not c_file.exists() or not h_file.exists():
        return True

    # Get newest image modification time
    img_extensions = {'.jpg', '.jpeg', '.png'}
    newest_img = 0
    for f in IMG_DIR.iterdir():
        if f.suffix.lower() in img_extensions:
            newest_img = max(newest_img, f.stat().st_mtime)

    # Get generated file modification time
    generated_time = min(c_file.stat().st_mtime, h_file.stat().st_mtime)

    return newest_img > generated_time


def main():
    if not IMG_DIR.exists():
        print(f"Image directory not found: {IMG_DIR}")
        sys.exit(1)

    # Check if regeneration needed (unless forced)
    force = "--force" in sys.argv
    if not force and not needs_regeneration():
        print("Images up to date, skipping generation")
        return 0

    # Find all images
    img_extensions = {'.jpg', '.jpeg', '.png'}
    img_files = sorted([f for f in IMG_DIR.iterdir()
                        if f.suffix.lower() in img_extensions])

    if not img_files:
        print(f"No images found in {IMG_DIR}")
        sys.exit(1)

    print(f"Converting {len(img_files)} images to RGB888...")

    images = []
    for img_path in img_files:
        name = sanitize_name(img_path.name)
        print(f"  Processing {img_path.name} -> {name}")
        pixels = process_image(img_path)
        images.append((name, pixels))

    generate_c_files(images)

    total_bytes = sum(len(pixels) for _, pixels in images)
    print(f"Total image data: {total_bytes:,} bytes ({total_bytes/1024:.1f} KB)")

    return 0


if __name__ == "__main__":
    sys.exit(main())
